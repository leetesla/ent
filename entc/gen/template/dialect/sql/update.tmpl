{{/*
Copyright 2019-present Facebook Inc. All rights reserved.
This source code is licensed under the Apache 2.0 license found
in the LICENSE file in the root directory of this source tree.
*/}}

{{ define "dialect/sql/update" }}
{{ $pkg := $.Scope.Package }}
{{ $builder := pascal $.Scope.Builder }}
{{ $receiver := receiver $builder }}
{{ $one := hasSuffix $builder "One" }}
{{- $zero := 0 }}{{ if $one }}{{ $zero = "nil" }}{{ end }}
{{- $ret := "n" }}{{ if $one }}{{ $ret = $.Receiver }}{{ end }}

func ({{ $receiver }} *{{ $builder }}) sqlSave(ctx context.Context) ({{ $ret }} {{ if $one }}*{{ $.Name }}{{ else }}int{{ end }}, err error) {
	spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table: {{ $.Package }}.Table,
			Columns: {{ $.Package }}.Columns,
			ID: &sqlgraph.FieldSpec{
				{{- if $one }}
					Value: {{ $receiver }}.id,
				{{- end }}
				Type: field.{{ $.ID.Type.ConstName }},
				Column: {{ $.Package }}.{{ $.ID.Constant }},
			},
		},
	}
	{{- if not $one }}
		if ps := {{ $receiver }}.predicates; len(ps) > 0 {
			spec.Predicate = func(selector *sql.Selector) {
				for i := range ps {
					ps[i](selector)
				}
			}
		}
	{{- end }}
	{{- range $_, $f := $.Fields }}
			{{- if or (not $f.Immutable) $f.UpdateDefault }}
				if value := {{ $receiver }}.{{ $f.BuilderField }}; value != nil {
					spec.Fields.Set = append(spec.Fields.Set, &sqlgraph.FieldSpec{
						Type: field.{{ $f.Type.ConstName }},
						Value: *value,
						Column: {{ $.Package }}.{{ $f.Constant }},
					})
				}
				{{- if $f.Type.Numeric }}
					if value := {{ $receiver }}.add{{ $f.BuilderField }}; value != nil {
						spec.Fields.Add = append(spec.Fields.Add, &sqlgraph.FieldSpec{
							Type: field.{{ $f.Type.ConstName }},
							Value: *value,
							Column: {{ $.Package }}.{{ $f.Constant }},
						})
					}
				{{- end }}
			{{- end }}
			{{- if $f.Optional }}
				if {{ $receiver }}.clear{{ $f.BuilderField }} {
					spec.Fields.Clear = append(spec.Fields.Clear, &sqlgraph.FieldSpec{
						Type: field.{{ $f.Type.ConstName }},
						Column: {{ $.Package }}.{{ $f.Constant }},
					})
				}
			{{- end }}
	{{- end }}
	{{- range $_, $e := $.Edges }}
		{{- if $e.Unique }}
			if {{ $receiver }}.cleared{{ $e.StructField }} {
				{{- with extend $ "Edge" $e }}
					{{ template "dialect/sql/defedge" . }}
				{{- end }}
				spec.Edges.Clear = append(spec.Edges.Clear, edge)
			}
		{{- else }}
			if nodes := {{ $receiver }}.removed{{ $e.StructField }}; len(nodes) > 0 {
				{{- with extend $ "Edge" $e "Nodes" true "Zero" $zero }}
					{{ template "dialect/sql/defedge" . }}
				{{- end }}
				spec.Edges.Clear = append(spec.Edges.Clear, edge)
			}
		{{- end }}
		if nodes := {{ $receiver }}.{{ $e.BuilderField }}; len(nodes) > 0 {
			{{- with extend $ "Edge" $e "Nodes" true "Zero" $zero }}
				{{ template "dialect/sql/defedge" . }}
			{{- end }}
			spec.Edges.Add = append(spec.Edges.Add, edge)
		}
	{{- end }}
	{{- if $one }}
		{{ $ret }} = &{{ $.Name }}{config: {{ $receiver }}.config}
		spec.ScanTypes = []interface{} {
			&{{ if not $.ID.UserDefined }}sql.NullInt64{{ else }}{{ $.ID.NullType }}{{ end }}{},
			{{- range $_, $f := $.Fields }}
				&{{ $f.NullType }}{},
			{{- end }}
		}
		spec.Assign = func(values ...interface{}) error {
			if m, n := len(values), len(spec.ScanTypes); m != n {
				return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
			}
			{{- if and $.ID.UserDefined (or $.ID.IsString $.ID.IsUUID) }}
				{{- with extend $ "Idx" 0 "Field" $.ID "Ret" $ret }}
					{{ template "dialect/sql/assignfield" . }}
				{{- end }}
			{{- else }}
				value, ok := values[0].(*sql.NullInt64)
				if !ok {
					return fmt.Errorf("unexpected type %T for field id", value)
				}
				{{ $ret }}.ID = {{ if $.ID.IsString }}strconv.FormatInt(value.Int64, 10){{ else }}{{ $.ID.Type }}(value.Int64){{ end }}
			{{- end }}
			values = values[1:]
			{{- range $i, $f := $.Fields }}
				{{- with extend $ "Idx" $i "Field" $f "Ret" $ret }}
					{{ template "dialect/sql/assignfield" . }}
				{{- end }}
			{{- end }}
			return nil
		}
	{{- end }}
	{{- if $one }}
		if err = sqlgraph.UpdateNode(ctx, {{ $receiver }}.driver, spec); err != nil {
	{{- else }}
		if {{ $ret }}, err = sqlgraph.UpdateNodes(ctx, {{ $receiver }}.driver, spec); err != nil {
	{{- end }}
		if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return {{ $zero }}, err
	}
	return {{ $ret }}, nil
}
{{ end }}

{{ define "dialect/sql/defedge" }}
	{{- $e := $.Scope.Edge -}}
	edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.{{ $e.Rel.Type }},
		Inverse: {{ $e.IsInverse }},
		Table: {{ $.Package }}.{{ $e.TableConstant }},
		Columns: {{ if $e.M2M }}{{ $.Package }}.{{ $e.PKConstant }}{{ else }}[]string{ {{ $.Package }}.{{ $e.ColumnConstant }} }{{ end }},
		Bidi: {{ $e.SelfRef }},
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.{{ $e.Type.ID.Type.ConstName }},
				Column: {{ $e.Type.Package }}.{{ $e.Type.ID.Constant }},
			},
		},
	}
	{{- with $.Scope.Nodes }}
		for k, _ := range nodes {
			{{- $id := $e.Type.ID -}}
			{{- /* Convert string-ids that are stored as int in the database */ -}}
			{{- if and (not $id.UserDefined) $id.IsString }}
				k, err := strconv.Atoi(k)
				if err != nil {
					return {{ $.Scope.Zero }}, err
				}
			{{- end }}
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
	{{- end }}
{{- end }}

{{ define "dialect/sql/assignfield" }}
	{{- $i := $.Scope.Idx -}}
	{{- $f := $.Scope.Field -}}
	{{- $ret := $.Scope.Ret -}}
	{{- if $f.IsJSON }}
		if value, ok := values[{{ $i }}].(*{{ $f.NullType }}); !ok {
			return fmt.Errorf("unexpected type %T for field {{ $f.Name }}", values[{{ $i }}])
		} else if value != nil && len(*value) > 0 {
			if err := json.Unmarshal(*value, &{{ $ret }}.{{ $f.StructField }}); err != nil {
				return fmt.Errorf("unmarshal field {{ $f.Name }}: %v", err)
			}
		}
	{{- else }}
		{{- $nulltype := $f.NullType -}}
		if value, ok := values[{{ $i }}].(*{{ $nulltype }}); !ok {
			return fmt.Errorf("unexpected type %T for field {{ $f.Name }}", values[{{ $i }}])
		{{- if hasPrefix $nulltype "sql" }}
			} else if value.Valid {
				{{- if $f.Nillable }}
					{{ $ret }}.{{ $f.StructField }} = new({{ $f.Type }})
					*{{ $ret }}.{{ $f.StructField }} = {{ $f.NullTypeField "value" }}
				{{- else }}
					{{ $ret }}.{{ $f.StructField }} = {{ $f.NullTypeField "value" }}
				{{- end }}
		{{- else }}
			} else if value != nil {
				{{ $ret }}.{{ $f.StructField }} = *value
		{{- end }}
		}
	{{- end }}
{{- end }}
